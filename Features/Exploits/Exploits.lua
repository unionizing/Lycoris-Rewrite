---@module Utility.Maid
local Maid = require("Utility/Maid")

-- Void maid.
local voidMaid = Maid.new()

---Void part.
---@param model Model
---@param part Part
---@param map OriginalStoreManager
local function voidPart(model, part, map)
	---@note: Remove part controllers.
	local velocityController = part:FindFirstChild("ControlVel")
		or part:FindFirstChild("SafetyBV")
		or part:FindFirstChild("SwimBV")
		or part:FindFirstChild("Holder")

	if velocityController and velocityController:IsA("BodyMover") then
		velocityController:Destroy()
	end

	-- Make it collidable with nothing.
	map:add(part, "CanCollide", false)

	-- Make the model collidable with nothing.
	for _, descendant in next, model:GetDescendants() do
		if not descendant:IsA("BasePart") then
			continue
		end

		map:add(descendant, "CanCollide", false)
	end

	-- Stop part from sleeping.
	sethiddenproperty(part, "NetworkIsSleeping", false)
end

return LPH_NO_VIRTUALIZE(function()
	-- Exploits related stuff is handled here.
	local Exploits = { ownershipTimestamp = 0, ownershipItem = nil, currentRootPart = nil }

	---@module Utility.Signal
	local Signal = require("Utility/Signal")

	---@module Utility.Configuration
	local Configuration = require("Utility/Configuration")

	---@module Utility.OriginalStore
	local OriginalStore = require("Utility/OriginalStore")

	---@module Features.Game.OwnershipWatcher
	local OwnershipWatcher = require("Features/Game/OwnershipWatcher")

	---@module Utility.Logger
	local Logger = require("Utility/Logger")

	-- Services.
	local runService = game:GetService("RunService")
	local players = game:GetService("Players")
	local physicsService = game:GetService("PhysicsService")
	local replicatedStorage = game:GetService("ReplicatedStorage")

	-- Collision group name using our unique table.
	local collisionGroupName = tostring(Exploits)

	-- Maids.
	local exploitsMaid = Maid.new()
	local pathfindBreakerMaid = Maid.new()

	-- Original stores.
	local allowSleep = voidMaid:mark(OriginalStore.new())

	-- Signals.
	local heartbeat = Signal.new(runService.Heartbeat)

	---Clean up void mobs.
	local function cleanVoidMobs()
		-- Clean up maps.
		voidMaid:clean()
		allowSleep:restore()

		-- Restore part maps.
		for _, data in next, OwnershipWatcher.parts do
			local map = data.map
			if not map then
				continue
			end

			map:restore()
		end
	end

	---Update void mobs.
	local function updateVoidMobs()
		local localPlayer = players.LocalPlayer

		-- Set simulation radius.
		sethiddenproperty(localPlayer, "MaxSimulationRadius", 9e9)
		sethiddenproperty(localPlayer, "SimulationRadius", 9e9)

		-- Set allow sleep.
		allowSleep:set(settings().Physics, "AllowSleep", false)

		---@type BasePart
		for part, data in next, OwnershipWatcher.parts do
			local model = data.model
			if not model then
				continue
			end

			local map = data.map
			if not map then
				continue
			end

			-- Check for ownership. If we don't have it, then we need to reset what we changed during void.
			if not data.owned then
				-- Restore.
				data.map:restore()

				-- Continue.
				continue
			end

			---@todo: Filtering out parts (CheckPartConnections, missing checks, etc)
			local localCharacter = localPlayer and localPlayer.Character
			if not localCharacter then
				continue
			end

			if model == localCharacter then
				continue
			end

			if model.Parent ~= workspace.Live then
				continue
			end

			voidPart(model, part, map)
		end
	end

	---Get knocked ownership item.
	local function getKnockedOwnershipItem()
		local localPlayer = players.LocalPlayer
		if not localPlayer then
			return
		end

		local backpack = localPlayer:FindFirstChild("Backpack")
		if not backpack then
			return
		end

		local selected = nil

		for _, item in pairs(backpack:GetChildren()) do
			if item.Name:match("Talent") then
				continue
			end

			if not item:IsA("Tool") then
				continue
			end

			if not item:FindFirstChildOfClass("BasePart") then
				continue
			end

			selected = item
		end

		if not selected then
			selected = localPlayer.Character and localPlayer.Character:FindFirstChild("Weapon")
			selected = selected or backpack:FindFirstChild("Weapon")
		end

		return selected
	end

	---Update move while knocked.
	local function updateMoveWhileKnocked()
		local effectReplicator = replicatedStorage:FindFirstChild("EffectReplicator")
		local effectReplicatorModule = require(effectReplicator)

		if not effectReplicatorModule:FindEffect("Knocked") then
			return
		end

		local localPlayer = players.LocalPlayer
		if not localPlayer then
			return
		end

		local character = localPlayer.Character
		if not character then
			return
		end

		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if not rootPart or rootPart.ReceiveAge == 0 then
			return
		end

		local humanoid = character:FindFirstChild("Humanoid")
		if not humanoid then
			return
		end

		local backpack = localPlayer:FindFirstChild("Backpack")
		if not backpack then
			return
		end

		local ownershipItem = Exploits.ownershipItem or getKnockedOwnershipItem()
		if not ownershipItem then
			return
		end

		if not Exploits.ownershipItem or not Exploits.ownershipItem:IsDescendantOf(game) then
			Exploits.ownershipItem = ownershipItem
		end

		if tick() - Exploits.ownershipTimestamp <= 0.15 then
			return
		end

		if ownershipItem.Parent == character then
			return humanoid:UnequipTools()
		end

		if ownershipItem.Parent == backpack then
			ownershipItem.Parent = character
		end

		Exploits.ownershipTimestamp = tick()
	end

	---Update exploits.
	local function updateExploits()
		local localPlayer = players.LocalPlayer
		if not localPlayer then
			return
		end

		if Configuration.expectToggleValue("VoidMobs") then
			updateVoidMobs()
		else
			cleanVoidMobs()
		end

		if Configuration.expectToggleValue("MoveWhileKnocked") then
			updateMoveWhileKnocked()
		end
	end

	---Initalize exploits.
	function Exploits.init()
		exploitsMaid:add(heartbeat:connect("Exploits_Heartbeat", updateExploits))

		---@note: Wrapped in a PCall to prevent errors.
		pcall(function()
			physicsService:RegisterCollisionGroup(collisionGroupName)
			physicsService:CollisionGroupSetCollidable(collisionGroupName, collisionGroupName, false)
			physicsService:CollisionGroupSetCollidable(collisionGroupName, "Default", false)
			physicsService:CollisionGroupSetCollidable(collisionGroupName, "Player", false)
			physicsService:CollisionGroupSetCollidable(collisionGroupName, "WalkThrough", false)
		end)

		-- Log.
		Logger.warn("Exploits initialized.")
	end

	---Detach voidMobs.
	function Exploits.detach()
		-- Clean.
		exploitsMaid:clean()
		voidMaid:clean()
		pathfindBreakerMaid:clean()

		-- Log.
		Logger.warn("Exploits detached.")
	end

	-- Return Exploits module.
	return Exploits
end)()
