---@module Utility.Maid
local Maid = require("Utility/Maid")

---@module Utility.InstanceWrapper
local InstanceWrapper = require("Utility/InstanceWrapper")

-- Void maid.
local voidMaid = Maid.new()

---Void part.
---@param model Model
---@param part Part
local function voidPart(model, part)
	---@note: Push the part down constantly in an attempt to get it to fall through the void.
	---This also has the positive note of making the part not sleep - retaining it.
	if not part:FindFirstChild("BodyVelocity") then
		local partConstantVelocity = InstanceWrapper.create(voidMaid, part, "BodyVelocity", part)
		partConstantVelocity.MaxForce = Vector3.new(1 / 0, 1 / 0, 1 / 0)
		partConstantVelocity.Velocity = Vector3.new(100, -100000, 0)
		partConstantVelocity.P = 1 / 0
	end

	---@note: Remove part controllers.
	local velocityController = part:FindFirstChild("ControlVel")
		or part:FindFirstChild("SafetyBV")
		or part:FindFirstChild("SwimBV")
		or part:FindFirstChild("Holder")

	if velocityController and velocityController:IsA("BodyMover") then
		velocityController:Destroy()
	end

	-- Set part properties.
	part.AssemblyLinearVelocity = Vector3.new(1000, -10000, 0)
	part.Position = Vector3.new(part.Position.X, -4000, part.Position.Z)
	part.CanCollide = false

	-- Stop part from sleeping.
	sethiddenproperty(part, "NetworkIsSleeping", false)
end

return LPH_NO_VIRTUALIZE(function()
	-- Exploits related stuff is handled here.
	local Exploits = { forceVoid = false, ownershipTimestamp = 0, ownershipItem = nil, currentRootPart = nil }

	---@module Utility.Signal
	local Signal = require("Utility/Signal")

	---@module Utility.Configuration
	local Configuration = require("Utility/Configuration")

	---@module Utility.OriginalStore
	local OriginalStore = require("Utility/OriginalStore")

	---@module Features.Game.OwnershipWatcher
	local OwnershipWatcher = require("Features/Game/OwnershipWatcher")

	---@module Utility.Logger
	local Logger = require("Utility/Logger")

	---@module Features.Automation.EchoFarm
	local EchoFarm = require("Features/Automation/EchoFarm")

	-- Services.
	local runService = game:GetService("RunService")
	local players = game:GetService("Players")
	local physicsService = game:GetService("PhysicsService")
	local replicatedStorage = game:GetService("ReplicatedStorage")

	-- Collision group name using our unique table.
	local collisionGroupName = tostring(Exploits)

	-- Maids.
	local exploitsMaid = Maid.new()
	local pathfindBreakerMaid = Maid.new()

	-- Original stores.
	local allowSleep = voidMaid:mark(OriginalStore.new())

	-- Signals.
	local heartbeat = Signal.new(runService.Heartbeat)
	local preRender = Signal.new(runService.PreRender)

	-- Last velocity before breaker modification.
	local lastVelocity = nil

	-- Last Vector
	local lastVector = 1

	---Clean up void mobs.
	local function cleanVoidMobs()
		voidMaid:clean()
		allowSleep:restore()
	end

	---Update void mobs.
	local function updateVoidMobs()
		local localPlayer = players.LocalPlayer

		-- Set simulation radius.
		if setsimulationradius then
			setsimulationradius(math.huge, math.huge)
		else
			sethiddenproperty(localPlayer, "MaxSimulationRadius", 9e9)
			sethiddenproperty(localPlayer, "SimulationRadius", 9e9)
		end

		-- Set allow sleep.
		allowSleep:set(settings().Physics, "AllowSleep", false)

		---@type BasePart
		for part, data in next, OwnershipWatcher.parts do
			local model = data.model
			if not model then
				continue
			end

			-- Check for ownership. If we don't have it, then we need to reset what we changed during void.
			if not data.owned then
				continue
			end

			---@todo: Filtering out parts (CheckPartConnections, missing checks, etc)
			local localCharacter = localPlayer and localPlayer.Character
			if not localCharacter then
				continue
			end

			if model == localCharacter then
				continue
			end

			if model.Parent ~= workspace.Live then
				continue
			end

			---@note: Set the part to not collide.
			for _, instance in pairs(model:GetChildren()) do
				if instance:IsA("BasePart") then
					instance.CanCollide = false
				end

				local bone = instance:FindFirstChild("Bone")
				if not bone or not bone:IsA("BasePart") then
					continue
				end

				bone.CanCollide = false
			end

			voidPart(model, part)
		end
	end

	---Get knocked ownership item.
	local function getKnockedOwnershipItem()
		local localPlayer = players.LocalPlayer
		if not localPlayer then
			return
		end

		local backpack = localPlayer:FindFirstChild("Backpack")
		if not backpack then
			return
		end

		local selected = nil

		for _, item in pairs(backpack:GetChildren()) do
			if item.Name:match("Talent") then
				continue
			end

			if not item:IsA("Tool") then
				continue
			end

			if not item:FindFirstChildOfClass("BasePart") then
				continue
			end

			selected = item
		end

		if not selected then
			selected = localPlayer.Character and localPlayer.Character:FindFirstChild("Weapon")
			selected = selected or backpack:FindFirstChild("Weapon")
		end

		return selected
	end

	---Update move while knocked.
	local function updateMoveWhileKnocked()
		local effectReplicator = replicatedStorage:FindFirstChild("EffectReplicator")
		local effectReplicatorModule = require(effectReplicator)

		if not effectReplicatorModule:FindEffect("Knocked") then
			return
		end

		local localPlayer = players.LocalPlayer
		if not localPlayer then
			return
		end

		local character = localPlayer.Character
		if not character then
			return
		end

		local rootPart = character:FindFirstChild("HumanoidRootPart")
		if not rootPart then
			return
		end

		local humanoid = character:FindFirstChild("Humanoid")
		if not humanoid then
			return
		end

		local backpack = localPlayer:FindFirstChild("Backpack")
		if not backpack then
			return
		end

		local ownershipItem = Exploits.ownershipItem or getKnockedOwnershipItem()
		if not ownershipItem then
			return
		end

		if not Exploits.ownershipItem or not Exploits.ownershipItem:IsDescendantOf(game) then
			Exploits.ownershipItem = ownershipItem
		end

		if tick() - Exploits.ownershipTimestamp <= 0.15 then
			return
		end

		local leftHand = character:FindFirstChild("LeftHand")
		local rightHand = character:FindFirstChild("RightHand")
		local hasHandWeapon = false

		if leftHand and leftHand:FindFirstChild("HandWeapon") then
			hasHandWeapon = true
		end

		if rightHand and rightHand:FindFirstChild("HandWeapon") then
			hasHandWeapon = true
		end

		local characterHandler = character:FindFirstChild("CharacterHandler")
		local requests = characterHandler and characterHandler:FindFirstChild("Requests")
		local equipWeapon = requests and requests:FindFirstChild("EquipWeapon")

		if ownershipItem.Name == "Weapon" and hasHandWeapon then
			return equipWeapon and equipWeapon:FireServer(false)
		end

		if ownershipItem.Name == "Weapon" and not hasHandWeapon then
			return equipWeapon and equipWeapon:FireServer(true)
		end

		if ownershipItem.Parent == character then
			return humanoid:UnequipTools()
		end

		if ownershipItem.Parent == backpack then
			humanoid:EquipTool(ownershipItem)
		end

		Exploits.ownershipTimestamp = tick()
	end

	---Update pathfind breaker heartbeat.
	local function updatePathfindBreakerHeartbeat()
		local character = players.LocalPlayer.Character
		if not character then
			return
		end

		local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
		if not humanoidRootPart then
			return
		end

		lastVelocity = humanoidRootPart.AssemblyLinearVelocity

		if Configuration.expectToggleValue("AggressiveMode") then
			humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, -1e5, 0)
		else
			humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, -9e9, 0)
		end

		if not Configuration.expectToggleValue("PathfindBreakerHighlight") then
			return pathfindBreakerMaid:clean()
		end

		local highlight = InstanceWrapper.create(pathfindBreakerMaid, "PathfindBreakerHighlight", "Highlight")
		highlight.FillColor = Configuration.expectOptionValue("PathfindBreakerHighlightColor")
		highlight.OutlineColor = Configuration.expectOptionValue("PathfindBreakerHighlightOutlineColor")

		if humanoidRootPart.Parent then
			highlight.Parent = humanoidRootPart.Parent
		end
	end

	---Update exploits.
	local function updateExploits()
		local localPlayer = players.LocalPlayer
		if not localPlayer then
			return
		end

		if EchoFarm.voiding or Configuration.expectToggleValue("VoidMobs") then
			updateVoidMobs()
		else
			cleanVoidMobs()
		end

		if Configuration.expectToggleValue("MoveWhileKnocked") then
			updateMoveWhileKnocked()
		end

		if Configuration.expectToggleValue("PathfindBreaker") then
			updatePathfindBreakerHeartbeat()
		else
			lastVelocity = nil
			pathfindBreakerMaid:clean()
		end
	end

	---Update pathfind breaker.
	local function updatePathfindBreakerRender()
		if not lastVelocity then
			return
		end

		local character = players.LocalPlayer and players.LocalPlayer.Character
		if not character then
			return
		end

		local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
		if not humanoidRootPart then
			return
		end

		lastVector = lastVector * -1
		humanoidRootPart.AssemblyLinearVelocity = lastVelocity + (humanoidRootPart.CFrame.LookVector * (5 * lastVector))
	end

	---Initalize exploits.
	function Exploits.init()
		exploitsMaid:add(heartbeat:connect("Exploits_Heartbeat", updateExploits))
		exploitsMaid:add(preRender:connect("Exploits_PreRender", updatePathfindBreakerRender))

		---@note: Wrapped in a PCall to prevent errors.
		pcall(function()
			physicsService:RegisterCollisionGroup(collisionGroupName)
			physicsService:CollisionGroupSetCollidable(collisionGroupName, collisionGroupName, false)
			physicsService:CollisionGroupSetCollidable(collisionGroupName, "Default", false)
			physicsService:CollisionGroupSetCollidable(collisionGroupName, "Player", false)
			physicsService:CollisionGroupSetCollidable(collisionGroupName, "WalkThrough", false)
		end)

		-- Log.
		Logger.warn("Exploits initialized.")
	end

	---Detach voidMobs.
	function Exploits.detach()
		-- Clean.
		exploitsMaid:clean()
		voidMaid:clean()
		pathfindBreakerMaid:clean()

		-- Log.
		Logger.warn("Exploits detached.")
	end

	-- Return Exploits module.
	return Exploits
end)()
