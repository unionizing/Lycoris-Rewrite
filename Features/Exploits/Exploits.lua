-- Exploits related stuff is handled here.
local Exploits = { ownershipTimestamp = 0, ownershipItem = nil, currentRootPart = nil }

---@module Utility.Maid
local Maid = require("Utility/Maid")

---@module Utility.Signal
local Signal = require("Utility/Signal")

---@module Utility.Configuration
local Configuration = require("Utility/Configuration")

---@module Utility.OriginalStore
local OriginalStore = require("Utility/OriginalStore")

---@module Utility.OriginalStoreManager
local OriginalStoreManager = require("Utility/OriginalStoreManager")

---@module Features.Game.OwnershipWatcher
local OwnershipWatcher = require("Features/Game/OwnershipWatcher")

---@module Utility.InstanceWrapper
local InstanceWrapper = require("Utility/InstanceWrapper")

-- Services.
local runService = game:GetService("RunService")
local players = game:GetService("Players")
local physicsService = game:GetService("PhysicsService")
local replicatedStorage = game:GetService("ReplicatedStorage")

-- Collision group name using our unique table.
local collisionGroupName = tostring(Exploits)

-- Maids.
local exploitsMaid = Maid.new()
local voidMaid = Maid.new()
local pathfindBreakerMaid = Maid.new()

-- Original stores.
local allowSleep = voidMaid:mark(OriginalStore.new())

-- Original stores managers.
local pathfindBreakerMap = pathfindBreakerMaid:mark(OriginalStoreManager.new())

-- Signals.
local renderStepped = Signal.new(runService.RenderStepped)
local heartbeat = Signal.new(runService.Heartbeat)

---Update void mobs.
local function updateVoidMobs()
	local localPlayer = players.LocalPlayer

	-- Set simulation radius.
	sethiddenproperty(localPlayer, "MaxSimulationRadius", math.huge)
	sethiddenproperty(localPlayer, "SimulationRadius", math.huge)

	-- Set allow sleep.
	allowSleep:set(settings().Physics, "AllowSleep", false)

	for part, data in next, OwnershipWatcher.parts do
		if not data.owned then
			continue
		end

		local model = data.model
		if not model then
			continue
		end

		---@todo: Filtering out parts (CheckPartConnections, missing checks, etc)
		local localCharacter = localPlayer and localPlayer.Character
		if not localCharacter then
			continue
		end

		if model == localCharacter then
			continue
		end

		if model.Parent ~= workspace.Live then
			continue
		end

		---@note: Set the part to not collide.
		for _, instance in pairs(model:GetChildren()) do
			if instance:IsA("BasePart") then
				instance.CanCollide = false
			end

			local bone = instance:FindFirstChild("Bone")
			if not bone or not bone:IsA("BasePart") then
				continue
			end

			bone.CanCollide = false
		end

		---@note: Push the part down constantly in an attempt to get it to fall through the void.
		---This also has the positive note of making the part not sleep - retaining it.
		if not part:FindFirstChild('BodyVelocity') then
			local partConstantVelocity = InstanceWrapper.create(voidMaid, part, "BodyVelocity", part)
			partConstantVelocity.MaxForce = Vector3.new(1 / 0, 1 / 0, 1 / 0)
			partConstantVelocity.Velocity = Vector3.new(0, -3500, 0)
			partConstantVelocity.P = 1 / 0
		end

		---@note: Remove part controllers.
		local velocityController = part:FindFirstChild("ControlVel")
		if velocityController then
			velocityController:Destroy()
		end

		local bodyVelocitySafety = part:FindFirstChild("SafetyBV")
		if bodyVelocitySafety then
			bodyVelocitySafety:Destroy()
		end

		local swimBodyVelocity = part:FindFirstChild("SwimBV")
		if swimBodyVelocity then
			swimBodyVelocity:Destroy()
		end

		local holder = part:FindFirstChild("Holder")
		if holder and holder:IsA("BodyMover") then
			holder:Destroy()
		end

		-- Stop part from sleeping.
		sethiddenproperty(part, "NetworkIsSleeping", false)
	end
end

---Get knocked ownership item.
local function getKnockedOwnershipItem()
	local localPlayer = players.LocalPlayer
	if not localPlayer then
		return
	end

	local backpack = localPlayer:FindFirstChild("Backpack")
	if not backpack then
		return
	end

	local selected = nil

	for _, item in pairs(backpack:GetChildren()) do
		if item.Name:match("Talent") then
			continue
		end

		if not item:IsA("Tool") then
			continue
		end

		if not item:FindFirstChildOfClass("BasePart") then
			continue
		end

		selected = item
	end

	if not selected then
		selected = localPlayer.Character and localPlayer.Character:FindFirstChild("Weapon")
		selected = selected or backpack:FindFirstChild("Weapon")
	end

	return selected
end

---Update move while knocked.
local function updateMoveWhileKnocked()
	local effectReplicator = replicatedStorage:FindFirstChild("EffectReplicator")
	local effectReplicatorModule = require(effectReplicator)

	if not effectReplicatorModule:FindEffect("Knocked") then
		return
	end

	local localPlayer = players.LocalPlayer
	if not localPlayer then
		return
	end

	local character = localPlayer.Character
	if not character then
		return
	end

	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if not rootPart or rootPart.ReceiveAge == 0 then
		return
	end

	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid then
		return
	end

	local backpack = localPlayer:FindFirstChild("Backpack")
	if not backpack then
		return
	end

	local ownershipItem = Exploits.ownershipItem or getKnockedOwnershipItem()
	if not ownershipItem then
		return
	end

	if not Exploits.ownershipItem or not Exploits.ownershipItem:IsDescendantOf(game) then
		Exploits.ownershipItem = ownershipItem
	end

	if tick() - Exploits.ownershipTimestamp <= 0.15 then
		return
	end

	if ownershipItem.Parent == character then
		return humanoid:UnequipTools()
	end

	if ownershipItem.Parent == backpack then
		ownershipItem.Parent = character
	end

	Exploits.ownershipTimestamp = tick()
end

---Update pathfind breaker.
local function updatePathfindBreaker()
	local localPlayer = players.LocalPlayer
	if not localPlayer then
		return
	end

	local character = localPlayer.Character
	if not character then
		return
	end

	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid then
		return
	end

	local rootPart = Exploits.currentRootPart or character:FindFirstChild("HumanoidRootPart")
	if not rootPart then
		return
	end

	local velocityScale = nil

	if Configuration.expectToggleValue("PathfindBreakerBringMob") then
		velocityScale = Vector3.new(0, -1e5, 0)
	else
		velocityScale = Vector3.new(0, 9e9, 0)
	end

	pathfindBreakerMap:add(rootPart.RootJoint, "Part0", nil)
	pathfindBreakerMap:add(rootPart, "Parent", humanoid)

	if not Exploits.currentRootPart then
		Exploits.currentRootPart = rootPart
	end

	local fakeRootPart = InstanceWrapper.mark(pathfindBreakerMaid, "fakeRootPart", rootPart:Clone())
	fakeRootPart.RootJoint.Part0 = fakeRootPart
	fakeRootPart.Parent = character

	local visualizationPart = InstanceWrapper.create(pathfindBreakerMaid, "visualizationPart", "Part", fakeRootPart)
	visualizationPart.Size = Vector3.new(4, 4, 4)
	visualizationPart.CanCollide = false
	visualizationPart.Transparency = 0.5
	visualizationPart.Material = Enum.Material.SmoothPlastic

	local visHighlight = InstanceWrapper.create(pathfindBreakerMaid, "visHighlight", "Highlight", visualizationPart)
	visHighlight.Enabled = Configuration.expectToggleValue("PathfindBreakerShowBody")
	visHighlight.FillColor = Configuration.expectOptionValue("PathfindBreakerBodyColor")
	visHighlight.OutlineColor = Color3.fromRGB(255, 255, 255)

	---@note: Mirror changes.
	local rootPartBodyVelocity = rootPart:FindFirstChildOfClass("BodyVelocity")
	if rootPartBodyVelocity then
		rootPartBodyVelocity.Parent = fakeRootPart
	end

	local rootPartBodyPosition = rootPart:FindFirstChildOfClass("BodyPosition")
	if rootPartBodyPosition then
		rootPartBodyPosition.Parent = fakeRootPart
	end

	local rootPartWeld = rootPart:FindFirstChildOfClass("Weld")
	if rootPartWeld then
		local part0 = rootPartWeld.Part0 == rootPart and fakeRootPart or rootPartWeld.Part0
		local part1 = rootPartWeld.Part1 == rootPart and fakeRootPart or rootPartWeld.Part1
		rootPartWeld.Parent = fakeRootPart
		rootPartWeld.Part0 = part0
		rootPartWeld.Part1 = part1
	end

	rootPart.CFrame = fakeRootPart.CFrame
	visualizationPart.CFrame = fakeRootPart.CFrame + velocityScale.Unit

	local oldVelocity = rootPart.AssemblyLinearVelocity
	rootPart.AssemblyLinearVelocity = rootPart.AssemblyLinearVelocity * velocityScale
	task.wait()
	rootPart.AssemblyLinearVelocity = oldVelocity
end

---Update exploits.
local function updateExploits()
	local localPlayer = players.LocalPlayer
	if not localPlayer then
		return
	end

	if Configuration.expectToggleValue("VoidMobs") then
		updateVoidMobs()
	else
		voidMaid:clean()
		allowSleep:restore()
	end

	if Configuration.expectToggleValue("MoveWhileKnocked") then
		updateMoveWhileKnocked()
	end
end

---Update heartbeat
local function updateHeartbeat()
	if Configuration.expectToggleValue("PathfindBreaker") then
		updatePathfindBreaker()
	else
		pathfindBreakerMaid:clean()
		Exploits.currentRootPart = nil
	end
end

---Initalize exploits.
function Exploits.init()
	exploitsMaid:add(renderStepped:connect("Exploits_RenderStepped", updateExploits))
	--exploitsMaid:add(heartbeat:connect("Exploits_Heartbeat", updateHeartbeat))

	---@note: Wrapped in a PCall to prevent errors.
	pcall(function()
		physicsService:RegisterCollisionGroup(collisionGroupName)
		physicsService:CollisionGroupSetCollidable(collisionGroupName, collisionGroupName, false)
		physicsService:CollisionGroupSetCollidable(collisionGroupName, "Default", false)
		physicsService:CollisionGroupSetCollidable(collisionGroupName, "Player", false)
		physicsService:CollisionGroupSetCollidable(collisionGroupName, "WalkThrough", false)
	end)
end

---Detach voidMobs.
function Exploits.detach()
	exploitsMaid:clean()
	voidMaid:clean()
	pathfindBreakerMaid:clean()
end

-- Return Exploits module.
return Exploits
