-- Exploits related stuff is handled here.
local Exploits = {}

---@module Utility.Maid
local Maid = require("Utility/Maid")

---@module Utility.Signal
local Signal = require("Utility/Signal")

---@module Utility.InstanceWrapper
local InstanceWrapper = require("Utility/InstanceWrapper")

---@module GUI.Configuration
local Configuration = require("GUI/Configuration")

-- Services.
local runService = game:GetService("RunService")
local players = game:GetService("Players")
local physicsService = game:GetService("PhysicsService")

-- Variables.
local voidMobsHeight = workspace.FallenPartsDestroyHeight + 100

-- Collision group name using our unique table.
local collisionGroupName = tostring(Exploits)

-- Instances.
local voidBaseParts = {}

-- Maids.
local exploitsMaid = Maid.new()

-- Signals.
local renderStepped = Signal.new(runService.RenderStepped)

---Do we have ownership of a base part?
---@param basePart BasePart
---@return boolean
local function hasOwnershipOfBasePart(basePart)
	---@note: This is an extremely long name but I just wanted to demonstrate what it's doing.
	local velocityMovingAndHasClientMover = false

	---@note: Constantly get the game to update the part velocity so we retain ownership & have a way to check for it.
	local clientVelocityMover = InstanceWrapper.create(exploitsMaid, basePart, "BodyVelocity", basePart)
	clientVelocityMover.MaxForce = Vector3.new(9e9, 9e9, 9e9)
	clientVelocityMover.P = 10000
	clientVelocityMover.Velocity = Vector3.new(0, -10, 0)
	clientVelocityMover:SetAttribute("Allowed", true)

	if
		clientVelocityMover.Parent == basePart
		and basePart.AssemblyLinearVelocity.Magnitude > 0
		and basePart.AssemblyAngularVelocity.Magnitude > 0
	then
		velocityMovingAndHasClientMover = true
	end

	return basePart.ReceiveAge == 0 and not basePart.Anchored and velocityMovingAndHasClientMover
end

---On live descendant added.
---@param descendant Instance
local function onLiveDescendantAdded(descendant)
	if not descendant:IsA("BasePart") then
		return
	end

	voidBaseParts[descendant] = descendant
end

---On live descendant removing.
---@param descendant Instance
local function onLiveDescendantRemoving(descendant)
	if not voidBaseParts[descendant] then
		return
	end

	voidBaseParts[descendant] = nil
end

---Update void mobs.
local function updateVoidMobs()
	for _, part in pairs(voidBaseParts) do
		---@todo: Filtering out parts (CheckPartConnections, missing checks, etc)

		if not hasOwnershipOfBasePart(part) then
			continue
		end

		---@note: Push the part down constantly in an attempt to get it to fall through the void.
		local partConstantVelocity = InstanceWrapper.create(exploitsMaid, part, "BodyVelocity", part)
		partConstantVelocity.MaxForce = Vector3.new(1 / 0, 1 / 0, 1 / 0)
		partConstantVelocity.Velocity = Vector3.new(0, workspace.StreamingEnabled and -8000 or -100, 0)
		partConstantVelocity.D = 0
		partConstantVelocity.P = 1 / 0

		local velocityController = part:FindFirstChild("ControlVel")
		if velocityController then
			velocityController:Destroy()
		end

		local bodyVelocitySafety = part:FindFirstChild("SafetyBV")
		if bodyVelocitySafety then
			bodyVelocitySafety:Destroy()
		end

		part.CanCollide = false
		part.CollisionGroup = collisionGroupName
		part.CFrame = CFrame.new(part.CFrame.X, voidMobsHeight, part.CFrame.Z)
		part.Velocity = Vector3.new(0, -12000, 0)

		sethiddenproperty(part, "NetworkIsSleeping", false)
	end
end

---Update exploits.
local function updateExploits()
	local localPlayer = players.LocalPlayer
	if not localPlayer then
		return
	end

	if Configuration.expectToggleValue("VoidMobs") then
		updateVoidMobs()
	end
end

---Initalize exploits.
function Exploits.init()
	local live = workspace:WaitForChild("Live")
	local liveDescendantAdded = Signal.new(live.DescendantAdded)
	local liveDescendantRemoving = Signal.new(live.DescendantRemoving)

	exploitsMaid:add(liveDescendantAdded:connect("Exploits_LiveDescendantAdded", onLiveDescendantAdded))
	exploitsMaid:add(liveDescendantRemoving:connect("Exploits_LiveDescendantRemoving", onLiveDescendantRemoving))
	exploitsMaid:add(renderStepped:connect("Exploits_RenderStepped", updateExploits))

	for _, descendant in pairs(live:GetDescendants()) do
		onLiveDescendantAdded(descendant)
	end

	---@note: Wrapped in a PCall to prevent errors.
	pcall(function()
		physicsService:RegisterCollisionGroup(collisionGroupName)
		physicsService:CollisionGroupSetCollidable(collisionGroupName, collisionGroupName, false)
		physicsService:CollisionGroupSetCollidable(collisionGroupName, "Default", false)
		physicsService:CollisionGroupSetCollidable(collisionGroupName, "Player", false)
		physicsService:CollisionGroupSetCollidable(collisionGroupName, "WalkThrough", false)
	end)
end

---Detach voidMobs.
function Exploits.detach()
	exploitsMaid:clean()
end

-- Return Exploits module.
return Exploits
