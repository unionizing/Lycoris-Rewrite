from pathlib import Path
import msgpack
import argparse

def load_msgpack(p: Path):
    if not p.exists() or p.stat().st_size == 0:
        return {}
    
    file_content = p.read_bytes()
    
    try:
        # Use an unpacker and feed it the data.
        # This is more robust for files that might have extra trailing data.
        unpacker = msgpack.Unpacker(raw=False)
        unpacker.feed(file_content)
        return next(unpacker)
    except (msgpack.exceptions.ExtraData, StopIteration):
        # If the above fails, it might be a different packing issue.
        # Fallback to unpackb which can sometimes handle it.
        try:
            return msgpack.unpackb(file_content, raw=False)
        except msgpack.exceptions.ExtraData:
             # If unpackb also fails with extra data, try the unpacker again
             # but this time it's the last resort.
            try:
                unpacker = msgpack.Unpacker(raw=False)
                unpacker.feed(file_content)
                return next(unpacker)
            except (msgpack.exceptions.ExtraData, StopIteration):
                return {} # Return empty if all attempts fail
    except Exception:
        return {} # Catch any other unexpected errors during unpacking

def compare_timings(timing1, timing2):
    """Compares two timing dictionaries and returns a dict of modified fields."""
    modified_fields = {}
    all_keys = set(timing1.keys()) | set(timing2.keys())

    for key in all_keys:
        val1 = timing1.get(key)
        val2 = timing2.get(key)
        # Compare string representations to handle nested dicts/lists simply
        if str(val1) != str(val2): 
            modified_fields[key] = (val1, val2)
            
    return modified_fields

def main():
    parser = argparse.ArgumentParser(description="Compare and update timing data in two msgpack config files.")
    parser.add_argument("file1", type=Path, help="Path to the source config file.")
    parser.add_argument("file2", type=Path, help="Path to the destination config file to modify.")
    args = parser.parse_args()

    config1 = load_msgpack(args.file1)
    config2 = load_msgpack(args.file2)

    if not config2:
        print(f"Error: Could not load or parse the destination file: {args.file2}")
        return

    is_modified = False
    containers = ["animation", "part", "sound"]
    fields_to_sync = ['actions', 'mat', 'imdd', 'umoa', 'smod', 'hitbox', 'imxd', 'fhb', 'name']

    # --- 1. Modify specified fields ---
    print(f"--- Checking for modifications in fields: {', '.join(fields_to_sync)} ---")
    for container_name in containers:
        
        def get_timing_key(timing, container):
            if container == 'part':
                return timing.get('pname')
            return timing.get('_id')

        timings1_list = config1.get(container_name, [])
        timings2_list = config2.get(container_name, [])

        timings1 = {get_timing_key(t, container_name): t for t in timings1_list if get_timing_key(t, container_name)}
        timings2 = {get_timing_key(t, container_name): t for t in timings2_list if get_timing_key(t, container_name)}

        common_keys = set(timings1.keys()) & set(timings2.keys())

        for key in common_keys:
            timing1 = timings1[key]
            timing2 = timings2[key] # This is a reference to the dict in timings2_list

            for field in fields_to_sync:
                val1 = timing1.get(field)
                val2 = timing2.get(field)

                # Simple string comparison to handle nested structures easily
                if str(val1) != str(val2):
                    print(f"  Updating '{field}' for timing: {timing2.get('name', key)}")
                    timing2[field] = val1
                    is_modified = True
    
    
    # --- 2. Clean up 'smod' field ---
    print("\n--- Checking for 'smod' cleanup ---")
    for container_name in containers:
        timings_list = config2.get(container_name, [])
        for timing in timings_list:
            smod = timing.get('smod')
            
            def get_timing_key(timing, container):
                if container == 'part':
                    return timing.get('pname')
                return timing.get('_id')

            timing_key = get_timing_key(timing, container_name)

            if (smod and timing_key and "AutoGenerated" in smod and 
                smod.endswith('.lua') and smod.startswith(timing_key)):
                
                new_smod = smod[:-4] # Remove .lua
                if timing['smod'] != new_smod:
                    print(f"  Cleaning smod for timing: {timing.get('name', timing_key)}")
                    timing['smod'] = new_smod
                    is_modified = True

    # --- 3. Save the modified file ---
    if is_modified:
        print(f"\nChanges were made. Saving modified data to {args.file2}...")
        try:
            with open(args.file2, "wb") as f:
                packed = msgpack.packb(config2, use_bin_type=True)
                f.write(packed) # type: ignore
            print("Save complete.")
        except Exception as e:
            print(f"Error saving file: {e}")
    else:
        print("\nNo modifications were needed.")

if __name__ == "__main__":
    main()
